#version 450
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, std430) readonly buffer DirectoryBuffer { uint chunkIDs[]; } directory;
layout(binding = 1, std430) writeonly buffer PoolBuffer { uint voxels[]; } pool;

const int CHUNK_SIZE = 32;
const int WORLD_CHUNKS = 32;

layout(push_constant) uniform Constants {
    ivec3 startChunk; 
} pc;

float hash(vec3 p) {
    p  = fract( p*0.3183099 + .1 );
    p *= 17.0;
    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );
}

float noise(vec3 x) {
    vec3 i = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
    
    return mix(mix(mix( hash(i+vec3(0,0,0)), 
                        hash(i+vec3(1,0,0)),f.x),
                   mix( hash(i+vec3(0,1,0)), 
                        hash(i+vec3(1,1,0)),f.x),f.y),
               mix(mix( hash(i+vec3(0,0,1)), 
                        hash(i+vec3(1,0,1)),f.x),
                   mix( hash(i+vec3(0,1,1)), 
                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);
}

float fbm(vec3 x) {
    float v = 0.0;
    float a = 0.5;
    vec3 shift = vec3(100);
    for (int i = 0; i < 4; ++i) {
        v += a * noise(x);
        x = x * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

void main() {
    ivec3 chunkCoord = pc.startChunk + ivec3(gl_WorkGroupID.xyz);

    if (chunkCoord.x >= WORLD_CHUNKS || chunkCoord.y >= WORLD_CHUNKS || chunkCoord.z >= WORLD_CHUNKS) return;

    uint dirIndex = chunkCoord.x + (chunkCoord.y * WORLD_CHUNKS) + (chunkCoord.z * WORLD_CHUNKS * WORLD_CHUNKS);
    uint poolID = directory.chunkIDs[dirIndex];

    if (poolID == 0) return;

    int localX = int(gl_LocalInvocationID.x);
    int localY = int(gl_LocalInvocationID.y);
    
    uint chunkOffset = poolID * (CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);

    for (int z = 0; z < CHUNK_SIZE; z++) {
        ivec3 localPos = ivec3(localX, localY, z);
        ivec3 worldPos = (chunkCoord * CHUNK_SIZE) + localPos;

        vec3 noisePos = vec3(worldPos) * 0.03; 
        
        float density = fbm(noisePos);
        
        float heightBias = (float(worldPos.y) - 84.0) / 40.0; 
        
        float finalDensity = density - heightBias;

        uint blockID = 0; 

        if (finalDensity > 0.0) {
            blockID = 1; 
            
            if (finalDensity < 0.05 && worldPos.y > 60) {
                 blockID = 2; 
            }
        }

        
        if (worldPos.y < 3) blockID = 3; 

        uint localIndex = localX + (localY * CHUNK_SIZE) + (z * CHUNK_SIZE * CHUNK_SIZE);
        pool.voxels[chunkOffset + localIndex] = blockID;
    }
}
