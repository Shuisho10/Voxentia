#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform writeonly image2D resultImage;

layout(binding = 1) uniform Camera {
    mat4 viewInverse;
    mat4 projInverse;
    vec4 position;
} cam;

layout(binding = 2, std430) readonly buffer DirectoryBuffer { uint chunkIDs[]; } directory;
layout(binding = 3, std430) readonly buffer PoolBuffer { uint voxels[]; } pool;

const int CHUNK_SIZE = 32;
const int WORLD_CHUNKS = 32; 
const int WORLD_SIZE = 1024;

uint getVoxel(uint chunkPtr, ivec3 mapPos) {
    ivec3 localPos = mapPos % CHUNK_SIZE;
    if (localPos.x < 0) localPos.x += CHUNK_SIZE;
    if (localPos.y < 0) localPos.y += CHUNK_SIZE;
    if (localPos.z < 0) localPos.z += CHUNK_SIZE;
    uint localIndex = localPos.x + (localPos.y * CHUNK_SIZE) + (localPos.z * CHUNK_SIZE * CHUNK_SIZE);
    uint chunkOffset = chunkPtr * (CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);
    return pool.voxels[chunkOffset + localIndex];
}

vec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - rayOrigin) / rayDir;
    vec3 tMax = (boxMax - rayOrigin) / rayDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 getVoxelColor(uint id) {
    if (id == 1) return vec3(0.5, 0.5, 0.5); 
    if (id == 2) return vec3(0.2, 0.6, 0.1); 
    if (id == 3) return vec3(0.1, 0.1, 0.1); 
    return vec3(1.0, 0.0, 1.0);              
}

void main() {
    ivec2 screen_size = imageSize(resultImage);
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= screen_size.x || pixel.y >= screen_size.y) return;

    // --- RAY SETUP ---
    vec2 uv = (vec2(pixel) / vec2(screen_size)) * 2.0 - 1.0;
    vec4 target = cam.projInverse * vec4(uv.x, uv.y, 1.0, 1.0);
    vec3 rayDir = normalize((cam.viewInverse * vec4(normalize(target.xyz), 0.0)).xyz);
    vec3 rayPos = cam.position.xyz;

    vec3 sunDir = normalize(vec3(0.5, 1.0, -0.3));
    vec3 skyColor = mix(vec3(0.6, 0.7, 0.9), vec3(0.2, 0.4, 0.7), max(rayDir.y, 0.0));
    vec3 color = skyColor;

    vec2 tBox = intersectAABB(rayPos, rayDir, vec3(0.0), vec3(WORLD_SIZE));
    
    if (tBox.x < tBox.y && tBox.y > 0.0) {
        float tCurrent = max(0.0, tBox.x);
        vec3 currPos = rayPos + rayDir * (tCurrent + 0.001);

        vec3 mapPos = floor(currPos);
        vec3 stepSign = sign(rayDir);
        vec3 deltaDist = abs(vec3(1.0) / rayDir);
        
        vec3 distToNext;
        distToNext.x = (stepSign.x > 0) ? (mapPos.x + 1.0 - currPos.x) : (currPos.x - mapPos.x);
        distToNext.y = (stepSign.y > 0) ? (mapPos.y + 1.0 - currPos.y) : (currPos.y - mapPos.y);
        distToNext.z = (stepSign.z > 0) ? (mapPos.z + 1.0 - currPos.z) : (currPos.z - mapPos.z);
        
        vec3 sideDist = distToNext * deltaDist;
        sideDist += tCurrent; 

        ivec3 iMapPos = ivec3(mapPos);
        ivec3 step = ivec3(stepSign);
        vec3 mask = vec3(0.0);
        
        for (int i = 0; i < 512; i++) {
            if (iMapPos.x < 0 || iMapPos.x >= WORLD_SIZE ||
                iMapPos.y < 0 || iMapPos.y >= WORLD_SIZE ||
                iMapPos.z < 0 || iMapPos.z >= WORLD_SIZE) break;

            ivec3 chunkCoord = iMapPos / CHUNK_SIZE;
            if (chunkCoord.x >= WORLD_CHUNKS || chunkCoord.y >= WORLD_CHUNKS || chunkCoord.z >= WORLD_CHUNKS) break;

            uint chunkID = directory.chunkIDs[chunkCoord.x + (chunkCoord.y * WORLD_CHUNKS) + (chunkCoord.z * WORLD_CHUNKS * WORLD_CHUNKS)];

            if (chunkID == 0) {
                ivec3 voxelInChunk = iMapPos % CHUNK_SIZE;
                if (voxelInChunk.x < 0) voxelInChunk.x += CHUNK_SIZE;
                if (voxelInChunk.y < 0) voxelInChunk.y += CHUNK_SIZE;
                if (voxelInChunk.z < 0) voxelInChunk.z += CHUNK_SIZE;

                ivec3 stepsToBorder;
                stepsToBorder.x = (step.x > 0) ? (CHUNK_SIZE - voxelInChunk.x) : (voxelInChunk.x + 1);
                stepsToBorder.y = (step.y > 0) ? (CHUNK_SIZE - voxelInChunk.y) : (voxelInChunk.y + 1);
                stepsToBorder.z = (step.z > 0) ? (CHUNK_SIZE - voxelInChunk.z) : (voxelInChunk.z + 1);

                vec3 distToBorder;
                distToBorder.x = sideDist.x + (float(stepsToBorder.x) - 1.0) * deltaDist.x;
                distToBorder.y = sideDist.y + (float(stepsToBorder.y) - 1.0) * deltaDist.y;
                distToBorder.z = sideDist.z + (float(stepsToBorder.z) - 1.0) * deltaDist.z;

                float tJump = min(min(distToBorder.x, distToBorder.y), distToBorder.z);

                if (distToBorder.x <= distToBorder.y && distToBorder.x <= distToBorder.z) {
                    sideDist.x = distToBorder.x; 
                    iMapPos.x += step.x * (stepsToBorder.x - 1); 
                } 
                else if (distToBorder.y <= distToBorder.z) {
                    sideDist.y = distToBorder.y;
                    iMapPos.y += step.y * (stepsToBorder.y - 1);
                } 
                else {
                    sideDist.z = distToBorder.z;
                    iMapPos.z += step.z * (stepsToBorder.z - 1);
                }
                
            } 
            else {
                uint voxelID = getVoxel(chunkID, iMapPos);

                if (voxelID != 0) {
                    vec3 albedo = getVoxelColor(voxelID);
                    
                    vec3 normal = -stepSign * mask;
                    if (length(mask) < 0.1) normal = -stepSign; 

                    float diff = max(dot(normal, sunDir), 0.0);
                    float ambient = 0.3 + 0.2 * normal.y;
                    vec3 light = (diff * vec3(1.0, 0.95, 0.8) * 0.9) + ambient;
                    
                    color = albedo * light;
                    
                    float dist = 0.0;
                    if (mask.x > 0.5) dist = sideDist.x - deltaDist.x;
                    else if (mask.y > 0.5) dist = sideDist.y - deltaDist.y;
                    else dist = sideDist.z - deltaDist.z;

                    float fog = 1.0 - exp(-dist * 0.002);
                    color = mix(color, skyColor, fog);
                    break;
                }
            }

            mask = vec3(0.0);
            if (sideDist.x < sideDist.y) {
                if (sideDist.x < sideDist.z) {
                    sideDist.x += deltaDist.x;
                    iMapPos.x += step.x;
                    mask.x = 1.0;
                } else {
                    sideDist.z += deltaDist.z;
                    iMapPos.z += step.z;
                    mask.z = 1.0;
                }
            } else {
                if (sideDist.y < sideDist.z) {
                    sideDist.y += deltaDist.y;
                    iMapPos.y += step.y;
                    mask.y = 1.0;
                } else {
                    sideDist.z += deltaDist.z;
                    iMapPos.z += step.z;
                    mask.z = 1.0;
                }
            }
        }
    }

    imageStore(resultImage, pixel, vec4(color, 1.0));
}
