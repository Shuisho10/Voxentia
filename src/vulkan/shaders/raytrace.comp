#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform writeonly image2D resultImage;

layout(binding = 1) uniform Camera {
    mat4 viewInverse;
    mat4 projInverse;
    vec4 position;
} cam;

layout(binding = 2, std430) readonly buffer DirectoryBuffer {
    uint chunkIDs[]; 
} directory;

layout(binding = 3, std430) readonly buffer PoolBuffer {
    uint voxels[];
} pool;

const int WORLD_SIZE = 64;

bool isSolid(ivec3 p) {
    if (p.x < 0 || p.y < 0 || p.z < 0 || 
        p.x >= WORLD_SIZE || p.y >= WORLD_SIZE || p.z >= WORLD_SIZE) {
        return false;
    }
    int index = p.x + (p.y * WORLD_SIZE) + (p.z * WORLD_SIZE * WORLD_SIZE);
    
    return pool.voxels[index] > 0;
}

void main() {
    ivec2 screen_size = imageSize(resultImage);
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= screen_size.x || pixel.y >= screen_size.y) return;

    vec2 uv = (vec2(pixel) / vec2(screen_size)) * 2.0 - 1.0;
    vec4 target = cam.projInverse * vec4(uv.x, uv.y, 1.0, 1.0);
    vec3 rayDir = normalize((cam.viewInverse * vec4(normalize(target.xyz), 0.0)).xyz);
    vec3 rayPos = cam.position.xyz;

    vec3 boxMin = vec3(0.0);
    vec3 boxMax = vec3(WORLD_SIZE);
    
    vec3 t1 = (boxMin - rayPos) / rayDir;
    vec3 t2 = (boxMax - rayPos) / rayDir;
    vec3 tMin = min(t1, t2);
    vec3 tMax = max(t1, t2);
    float tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(tMax.x, tMax.y), tMax.z);

    vec3 color = vec3(0.1, 0.1, 0.15); 

    if (tNear < tFar && tFar > 0.0) {
        float t = max(0.0, tNear);
        vec3 currentPos = rayPos + rayDir * t;
        
        currentPos += rayDir * 0.001; 

        ivec3 mapPos = ivec3(floor(currentPos));
        vec3 deltaDist = abs(vec3(1.0) / rayDir);
        ivec3 rayStep = ivec3(sign(rayDir));
        vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - currentPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
        
        int side = 0;
        
        for (int i = 0; i < 200; i++) {
            if (mapPos.x < 0 || mapPos.x >= WORLD_SIZE ||
                mapPos.y < 0 || mapPos.y >= WORLD_SIZE ||
                mapPos.z < 0 || mapPos.z >= WORLD_SIZE) break;

            if (isSolid(mapPos)) {
                vec3 normal = vec3(0.0);
                if (side == 0) normal.x = -rayStep.x;
                else if (side == 1) normal.y = -rayStep.y;
                else normal.z = -rayStep.z;
                
                color = vec3(0.8, 0.5, 0.3);
                if (side == 1) color = vec3(0.3, 0.8, 0.3); 
                
                float diff = max(dot(normal, normalize(vec3(0.5, 1.0, 0.3))), 0.2);
                color *= diff;
                
                break;
            }

            if (sideDist.x < sideDist.y) {
                if (sideDist.x < sideDist.z) {
                    sideDist.x += deltaDist.x;
                    mapPos.x += rayStep.x;
                    side = 0;
                } else {
                    sideDist.z += deltaDist.z;
                    mapPos.z += rayStep.z;
                    side = 2;
                }
            } else {
                if (sideDist.y < sideDist.z) {
                    sideDist.y += deltaDist.y;
                    mapPos.y += rayStep.y;
                    side = 1;
                } else {
                    sideDist.z += deltaDist.z;
                    mapPos.z += rayStep.z;
                    side = 2;
                }
            }
        }
    }

    imageStore(resultImage, pixel, vec4(color, 1.0));
}
